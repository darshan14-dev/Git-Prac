//Merge

1)  ------> create a pull request
            -> and then merge using GitHub UI

2) -------> if you performed merge on your local device and then push to remote,
            it wont create a pr

3)--------> solving merge conflicts
           First, make sure youâ€™re on your branch:  git checkout feature

           Then, fetch the latest commits from the remote: git fetch origin

           To integrate changes from main into your branch, either merge or rebase:
           Merge approach:  git merge origin/main


           If there are conflicts, edit the conflicted files,
           remove Git markers (<<<<<<<, =======, >>>>>>>), then:

           git add <file>
           git commit


           Rebase approach (cleaner history):   git rebase origin/main


           Resolve conflicts if they appear:
           git add <file>
           git rebase --continue


           After successfully integrating changes, push your branch:
           After merge:

           git push origin feature

           After rebase (history changed â†’ force push):

           git push --force-with-lease

 main:    A --- B
 feature:       C --- D

                                 ---->       main:    A --- B -------- M
                                                              \       /
                                           feature:            C --- D

Git creates a new merge commit (unless itâ€™s a fast-forward merge)
This merge commit has two parents:
   -the previous main commit
   -the last commit of the feature branch
So none of the old commits are lost.



//Rebase

keeps the commit history linear ,old commits are rewrote and replaces they are still
stored in "Ref-Log" for 30-90 days before cleanup you can retrive them back

main:     A --- B --- C
                           \
feature:                     D' --- E'


ğŸ” Rebased wrong features â€“ what to do (quick guide)
1ï¸âƒ£ Rebased locally (NOT pushed) âœ…

ğŸ‘‰ Undo easily

git reflog
git reset --hard HEAD@{n}   # pre-rebase state


âœ” Branch restored
âœ” Old commits back

2ï¸âƒ£ Rebased and already pushed âš ï¸
A) Only you use the branch
git push --force


âœ” OK if no one else pulled

B) Shared branch âŒ (best practice)

Do NOT force push

Undo locally using reflog

Fix using new commits or revert

git reflog
git reset --hard <pre-rebase-hash>
git push


or

git revert <bad-commit>


âœ” Safe for team
âœ” History preserved

3ï¸âƒ£ Want to keep some commits

ğŸ‘‰ Use interactive rebase

git rebase -i main


drop â†’ remove wrong commit

edit â†’ modify commit

squash â†’ combine commits

4ï¸âƒ£ Reflog expired âŒ (worst case)

No branch/tag

GC ran

ğŸ‘‰ Commits are permanently lost

ğŸ” Golden safety rule

Before rebasing important work:

git branch backup-feature



------------squah------------------
# 1. Go to feature branch
git checkout feature

# 2. Start interactive rebase
git rebase -i HEAD~N

Example (last 3 commits):
git rebase -i HEAD~3



ğŸ§  What happens next

Git opens an editor:

pick a1 Add login page
pick b2 Fix login bug
pick c3 Update login UI


Change it to:

pick a1 Add login page
squash b2 Fix login bug
squash c3 Update login UI


(or s instead of squash)

Save & close.

ğŸ“ Commit message screen

Git now asks for a single commit message:

Add login page with bug fixes and UI updates


Save â†’ squash done âœ…

3ï¸âƒ£ How squash works internally (VERY IMPORTANT)
ğŸ”´ Before squash
A --- B --- C --- D

ğŸŸ¢ After squash
A --- E


E contains changes of B + C + D

B, C, D commits are GONE

New commit hash is created

History is rewritten

ğŸ‘‰ Squash = delete old commits + create one new commit

4ï¸âƒ£ Another way: Squash while merging
âœ… Command
git checkout main
git merge --squash feature
git commit

What this does:

Takes all changes from feature

Does NOT bring its commit history

Creates one new commit on main

ğŸ“Œ Feature branch commits still exist on the feature branch.


