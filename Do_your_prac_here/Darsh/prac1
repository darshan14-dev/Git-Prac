
===============================
GIT WORKFLOWS: MERGE, REBASE, SQUASH & REVERT , RESET
===============================

--------------------------------
MERGE
--------------------------------

1) Create a Pull Request (PR)
--------------------------------
‚Üí Create a pull request
‚Üí Merge using GitHub UI


2) Local Merge (No PR)
--------------------------------
‚Üí If you perform a merge on your local machine and push to remote,
  it will NOT create a Pull Request.


3) Solving Merge Conflicts
--------------------------------

Step 1: Make sure you are on your feature branch
--------------------------------
git checkout feature

Step 2: Fetch latest changes from remote
--------------------------------
git fetch origin

Step 3: Integrate changes from main into your branch
--------------------------------

MERGE approach:
git merge origin/main

If conflicts occur:
- Open conflicted files
- Remove Git markers:
  <<<<<<<
  =======
  >>>>>>>

Then run:
git add <file>
git commit


REBASE approach (cleaner history):
git rebase origin/main

If conflicts occur:
git add <file>
git rebase --continue


Step 4: Push your branch
--------------------------------

After MERGE:
git push origin feature

After REBASE (history changed ‚Üí force push required):
git push --force-with-lease


MERGE COMMIT STRUCTURE
--------------------------------

main:     A --- B
feature:        C --- D

After merge:

main:     A --- B -------- M
                   \     /
feature:            C --- D

‚Ä¢ Git creates a NEW merge commit (unless fast-forward)
‚Ä¢ Merge commit has TWO parents:
  - Previous main commit
  - Last commit of feature branch
‚Ä¢ NO old commits are lost


--------------------------------
REBASE
--------------------------------

‚Ä¢ Keeps commit history LINEAR
‚Ä¢ Old commits are REWRITTEN
‚Ä¢ Original commits are still stored in REFLOG
  (30‚Äì90 days before cleanup)

Example:

main:     A --- B --- C
                          \
feature:                    D' --- E'


--------------------------------
REBASED WRONG FEATURES ‚Äì QUICK GUIDE
--------------------------------

1Ô∏è‚É£ Rebased LOCALLY (NOT pushed)
--------------------------------
Undo easily:

git reflog
git reset --hard HEAD@{n}

‚úî Branch restored
‚úî Old commits recovered


2Ô∏è‚É£ Rebased AND ALREADY PUSHED ‚ö†

A) Only YOU use the branch
--------------------------------
git push --force

‚úî Safe if no one else pulled


B) SHARED branch  (Best Practice)
--------------------------------
DO NOT force push

Undo locally using reflog:
git reflog
git reset --hard <pre-rebase-hash>
git push

OR revert specific commits:
git revert <bad-commit>

‚úî Safe for team
‚úî History preserved


3Ô∏è‚É£ Want to KEEP some commits
--------------------------------
Use interactive rebase:

git rebase -i main

Options:
- drop   ‚Üí remove commit
- edit   ‚Üí modify commit
- squash ‚Üí combine commits


4Ô∏è‚É£ Reflog EXPIRED  (Worst Case)
--------------------------------
‚Ä¢ No branch or tag exists
‚Ä¢ Garbage Collection (GC) ran

üëâ Commits are PERMANENTLY LOST


üîê GOLDEN SAFETY RULE
--------------------------------
Before rebasing important work:

git branch backup-feature


--------------------------------
SQUASH
--------------------------------

1Ô∏è‚É£ Squash Commits using Interactive Rebase
--------------------------------

Step 1: Go to feature branch
git checkout feature

Step 2: Start interactive rebase
git rebase -i HEAD~N

Example (last 3 commits):
git rebase -i HEAD~3


üß† What happens next
--------------------------------

Git opens an editor:

pick a1 Add login page
pick b2 Fix login bug
pick c3 Update login UI


Change to:

pick a1 Add login page
squash b2 Fix login bug
squash c3 Update login UI

(or use 's' instead of 'squash')

Save & close.


üìù Commit Message Screen
--------------------------------
Git asks for a SINGLE commit message:

Add login page with bug fixes and UI updates

Save ‚Üí Squash completed


3Ô∏è‚É£ How Squash Works INTERNALLY (VERY IMPORTANT)
--------------------------------

üî¥ Before Squash:
A --- B --- C --- D

üü¢ After Squash:
A --- E

‚Ä¢ Commit E contains changes of B + C + D
‚Ä¢ Commits B, C, D are GONE
‚Ä¢ New commit hash is created
‚Ä¢ History is REWRITTEN

üëâ Squash = delete old commits + create ONE new commit


4Ô∏è‚É£ Squash While Merging (Alternative)
--------------------------------

Commands:
git checkout main
git merge --squash feature
git commit

What happens:
‚Ä¢ Takes ALL changes from feature
‚Ä¢ Does NOT bring commit history
‚Ä¢ Creates ONE new commit on main

üìå Feature branch commits STILL exist on feature branch


--------------------------------
REVERT
--------------------------------

Basic Command:
--------------------------------
git revert <commit>


Example History:
--------------------------------
A --- B --- C --- D (HEAD)

Run:
git revert B

Result:
A --- B --- C --- D --- R (HEAD)

‚Ä¢ R is a NEW commit
‚Ä¢ R reverses changes of commit B
‚Ä¢ Commit B is NOT removed
‚Ä¢ HEAD stays at latest commit


--------------------------------
REVERTING A MERGE COMMIT
--------------------------------

Command:
git revert -m 1 <merge-commit>

What -m 1 means:
--------------------------------
git revert -m 1 M

Verify using:
git show M

You will see:
parent1: C
parent2: F2

Meaning:
‚Ä¢ Keep parent 1 (main branch)
‚Ä¢ Undo changes from parent 2 (feature branch)

‚ö†Ô∏è Without -m option:
error: commit is a merge but no -m option was given


--------------------------------
OTHER REVERT OPTIONS
--------------------------------

‚Ä¢ Revert multiple commits:
git revert <commit1> <commit2> ...

‚Ä¢ Revert a range:
git revert <oldest-commit>^..<newest-commit>


--------------------------------
REVERT CONFLICT RESOLUTION
--------------------------------

‚Ä¢ Revert can cause conflicts (like merge)
‚Ä¢ Resolve conflicts manually
‚Ä¢ Then run:
git revert --continue


--------------------------------
UNDO LATEST COMMIT
--------------------------------

Shortcut:
git revert HEAD



--------------------------------
RESET
--------------------------------


| Command                 | Effect                            |
| ----------------------- | --------------------------------- |
| `git reset --soft`      | Keeps changes **staged**          |
| `git reset` / `--mixed` | Moves changes to **unstaged**     |
| `git reset --hard`      | Deletes staged + unstaged changes |



# GIT RESET

**Command:**
```
git reset [--soft | --mixed | --hard]
```
**Overview:**

* `git reset` moves **HEAD** to another commit.
* It can affect:

  * **HEAD** (commit pointer)
  * **Staging Area** (index)
  * **Working Directory** (files)
* Behavior depends on the mode used.

---

# GIT CORE CONCEPT ‚Äì 3 AREAS

```
Working Directory ‚Üí Staging Area ‚Üí Repository
```

* **Working Directory:** Where you edit files.
* **Staging Area:** Files prepared for commit.
* **Repository:** Committed history.

---

# RESET MODES (VERY IMPORTANT)

### 1. --soft

**Command:**
```
git reset --soft
```
**Effect:**

* Moves HEAD only
* Commits after are removed
* Changes remain **STAGED**

**Use when:**
* Fixing commit message
* Squashing commits

---

### 2. --mixed (DEFAULT)

**Command:**
```
git reset
```
or
```
git reset --mixed
```
**Effect:**
* Moves HEAD
* Clears **staging area**
* Changes remain in **working directory (UNSTAGED)**

**Use when:**
* Reorganizing what goes into commit

---
### 3. --hard (DANGEROUS)

**Command:**
```
git reset --hard
```
**Effect:**
* Moves HEAD
* Deletes commits after
* Deletes **all staged + unstaged changes**

**Use when:**
* Local cleanup
  ‚ùå **Never on shared branches**

---

# SCENARIOS

### Scenario 1: Unstage One File

**Command:**
```
git reset HEAD file.txt
```
**Result:**
* File removed from staging
* File changes preserved

---

### Scenario 2: Unstage All Files
**Command:**
```
git reset
```
or
```
git reset HEAD
```
**Result:**
* All staged files unstaged
* No commits deleted
* No file changes lost

---

### Scenario 3: Undo Last Commit (Keep Changes Staged)
**Command:**
```
git reset --soft HEAD~1
```
**Result:**
* Last commit deleted
* Changes remain staged

---
### Scenario 4: Undo Last Commit (Keep Changes Unstaged)
**Command:**

```
git reset HEAD~1
```

**Result:**

* Last commit deleted
* Changes remain in working directory

---

### Scenario 5: Delete Last Commit Completely

**Command:**

```
git reset --hard HEAD~1
```

**Result:**

* Commit deleted
* File changes deleted

---

### Scenario 6: Reset Multiple Commits

**Command:**

```
git reset --soft HEAD~3

git reset --hard HEAD~3
```

**Result:**

* HEAD moves back by 3 commits
* Commits removed based on mode

---

### Scenario 7: Reset After Push (Private Branch)

**Command:**

```
git reset --hard

git push --force-with-lease
```

**Result:**

* Remote history rewritten
* Safe **ONLY** if you are the sole user

---

### Scenario 8: Reset After Push (Shared Branch) ‚ùå

**Command (WRONG):**

```
git reset --hard

git push --force
```

**Why ‚ùå:**

* Breaks teammates‚Äô branches
* Deletes shared history

**Correct Approach ‚úî:**

* Use `git revert` instead

---

### Scenario 9: Reset Caused Mistake (Recovery)

**Use Reflog:**

```
git reflog
```

**Restore:**

```
git reset --hard <commit>
```

* Possible within reflog expiry (30‚Äì90 days)

---

# RESET VS REVERT

| Aspect  | **Reset**                 | **Revert**              |
| ------- | ------------------------- | ----------------------- |
| Commits | Deletes commits           | Adds new commit         |
| History | Rewrites history          | Preserves history       |
| Safety  | Unsafe on shared branches | Safe on shared branches |

---

# COMMON MISTAKES

‚ùå Using `--hard` blindly
‚ùå Resetting main branch
‚ùå Force pushing without coordination
‚ùå Forgetting reflog recovery

---

# MENTAL MODEL

```
--soft ‚Üí HEAD only
--mixed ‚Üí HEAD + index
--hard ‚Üí HEAD + index + files
```

---

# INTERVIEW ONE-LINER

*"git reset rewrites history by moving HEAD backward and is safe only on local or private branches, while git revert is safe for shared branches."*



GIT FETCH, REMOTE-TRACKING BRANCH, MERGE, AND REBASE
==================================================

1. BASIC TERMINOLOGY
-------------------

Local Repository:
- Your machine‚Äôs Git repository
- Contains your working code and local branches

Remote Repository:
- Central/shared repository (e.g., GitHub, GitLab)
- Example remote name: origin or remote

Local Branch:
- A branch you actively work on
- Example: main

Remote-Tracking Branch:
- A local, read-only reference to a remote branch
- Example: origin/main or remote/main


3. WHAT DOES `git fetch` DO?
----------------------------

Command:
git fetch <remote-name>

Example:
git fetch remote

What it DOES:
- Connects to the remote repository
- Downloads new commits
- Updates remote-tracking branches (remote/main)

What it DOES NOT do:
- Does NOT modify local branches
- Does NOT change working directory
- Does NOT merge
- Does NOT rebase
- Does NOT create commits

This is why git fetch is considered SAFE.


4. STATE BEFORE AND AFTER FETCH
-------------------------------

Before fetch:

Local branch:
local/main:      A --- B --- D

Remote-tracking branch:
remote/main:     A --- B --- C


After git fetch remote:

Local branch (unchanged):
local/main:      A --- B --- D

Remote-tracking branch (updated):
remote/main:     A --- B --- C --- E


5. WHY DOES `remote/main` MOVE AFTER FETCH?
-------------------------------------------

Because:
- remote/main is Git‚Äôs local reference to the remote branch
- git fetch updates this reference to match the remote‚Äôs latest commit
- Your local branch is NOT touched automatically

Key idea:
Fetch updates INFORMATION, not CODE.


6. WHAT HAPPENS AFTER FETCH?
----------------------------

After fetching, you decide how to integrate the changes.


6.1 MERGE
---------

6.2 REBASE
----------


7. RELATION BETWEEN FETCH, MERGE, REBASE, AND PULL
-------------------------------------------------

git fetch
- Downloads changes only

git merge
- Integrates changes using a merge commit

git rebase
- Integrates changes by replaying commits

git pull
- git fetch + git merge (default behavior)

git pull --rebase
- git fetch + git rebase


8. COMPLETE WORKFLOW SUMMARY
----------------------------

Step 1:
git fetch
‚Üí Updates remote-tracking branches

Step 2:
git merge OR git rebase
‚Üí Applies remote changes to the local branch

Golden Rule:
Fetch updates references.
Merge/Rebase updates your branch and code.




GIT CHERRY-PICK ‚Äî COMPLETE, STRUCTURED EXPLANATION
==================================================

1. WHAT IS GIT CHERRY-PICK?
--------------------------

Definition:
git cherry-pick applies the changes introduced by one (or more) specific
commit(s) onto the current branch by creating new commits.

Command:
git cherry-pick <commit-hash>

Important:
Cherry-pick COPIES a commit.
It does NOT move the original commit.


2. WHAT ACTUALLY HAPPENS INTERNALLY?
-----------------------------------

When you cherry-pick a commit:

- Git takes the DIFF (changes) of that commit
- Applies those changes on your current branch
- Creates a NEW commit with a NEW hash

So:
Original commit ‚â† Cherry-picked commit
(only the changes are the same)


3. BASIC EXAMPLE
----------------

Initial state:

main:          A --- B --- C
feature:       A --- B --- D --- E

You want ONLY commit D in main.

Command (on main):
git cherry-pick D

Result:

main:          A --- B --- C --- D'
feature:       A --- B --- D --- E

Key points:
- D' is a NEW commit
- D still exists on feature branch
- History is NOT merged


4. CHERRY-PICK WITH --NO-COMMIT
--------------------------------

Sometimes you want to **apply changes without committing immediately**, e.g., to squash multiple cherry-picks into one commit.

Command:
git cherry-pick --no-commit <commit-hash>
or
git cherry-pick -n <commit-hash>

Behavior:
- Applies changes from the commit to working directory and staging area
- Does NOT create a commit
- Lets you make additional edits or combine multiple cherry-picks
- You need to commit manually:

git commit -m "Combined commit"


5. IMPORTANT PROPERTIES
-----------------------

- Cherry-pick works on individual commits
- Creates new commit hashes (unless --no-commit, then you commit later)
- Preserves changes, not history
- Can cause conflicts
- Safe for selective fixes


6. MULTIPLE CHERRY-PICKS
------------------------

Pick multiple commits:

git cherry-pick D E

Pick a range (exclusive ‚Üí inclusive):

git cherry-pick D^..F

With --no-commit:

git cherry-pick -n D E
# then commit manually after combining


7. CONFLICTS DURING CHERRY-PICK
--------------------------------

If conflicts occur:

1. Git pauses cherry-pick
2. You resolve conflicts manually
3. Stage resolved files
4. Continue:

git cherry-pick --continue

Abort cherry-pick:
git cherry-pick --abort


8. WHEN SHOULD YOU USE CHERRY-PICK?
-----------------------------------

SCENARIO 1: HOTFIX FROM FEATURE TO MAIN
---------------------------------------

- Bug fixed in feature branch
- Only ONE commit is needed in main
- You don‚Äôt want full feature

Use cherry-pick ‚úÖ

SCENARIO 2: BACKPORTING A FIX
-----------------------------

- Bug fixed in main
- Need same fix in release or production branch

Use cherry-pick ‚úÖ

SCENARIO 3: SELECTIVE COMMITS
-----------------------------

- Feature branch has many commits
- You want only specific, stable ones

Use cherry-pick ‚úÖ


9. WHEN NOT TO USE CHERRY-PICK
------------------------------

‚ùå To integrate an entire branch
‚ùå When commit order matters deeply
‚ùå On long-lived shared branches (can duplicate history)
‚ùå When merge or rebase is cleaner


10. CHERRY-PICK vs MERGE vs REBASE
---------------------------------

MERGE:
- Brings entire branch
- Preserves history
- No commit rewriting

REBASE:
- Rewrites history
- Replays all commits
- Clean linear history

CHERRY-PICK:
- Copies selected commits
- Creates new commits
- No branch relationship preserved


11. DANGERS OF CHERRY-PICK
--------------------------

- Duplicate commits can occur
- Same fix may exist twice with different hashes
- Can cause future merge conflicts

Rule:
If you cherry-pick a commit, avoid merging the same branch later.


12. HOW TO IDENTIFY A CHERRY-PICKED COMMIT
------------------------------------------

Git message:
(cherry picked from commit <hash>)

Use:
git log --cherry


13. INTERVIEW-READY ONE-LINERS
------------------------------

- "Cherry-pick applies a specific commit‚Äôs changes onto another branch."
- "Cherry-pick copies commits; it does not move them."
- "Cherry-pick creates new commit hashes."
- "Use cherry-pick for hotfixes and backporting."
- "--no-commit option applies changes without committing, allowing manual adjustments or combining commits."


14. FINAL MENTAL MODEL
----------------------

MERGE   ‚Üí bring everything
REBASE  ‚Üí replay everything
CHERRY  ‚Üí pick exactly what you want


END OF FILE



